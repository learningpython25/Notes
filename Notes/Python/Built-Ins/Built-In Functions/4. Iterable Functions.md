**Processing Iterables and Iterators**
- *`len()`*
- *`reversed()`*
- *`sorted()`*
- *`all()`*
- *`any()`*
- *`range()`*
- `enumerate()`
- `slice()`



## `enumerate()`

### What It Does:

* Adds a **counter** to an iterable and returns it as an **enumerate object** (which is an iterator of tuples).
* Useful in `for` loops where you need both index and value.

### Syntax:

```python
enumerate(iterable, start=0)
```

### Example:

```python
names = ['Alice', 'Bob', 'Charlie']
for index, name in enumerate(names):
    print(index, name)

# Output:
# 0 Alice
# 1 Bob
# 2 Charlie
```

### With Custom Start:

```python
for index, name in enumerate(names, start=1):
    print(index, name)

# Output:
# 1 Alice
# 2 Bob
# 3 Charlie
```

---

## `slice()`

### What It Does:

* Creates a **slice object**, which can be used to specify a range of indices to extract from sequences like lists, strings, etc.
* Equivalent to the `[start:stop:step]` syntax but allows dynamic slicing.

### Syntax:

```python
slice(start, stop[, step])
```

### Example:

```python
s = 'abcdefgh'
sl = slice(2, 6)
print(s[sl])   # 'cdef'
```

### With Step:

```python
s = 'abcdefgh'
print(s[slice(1, 7, 2)])  # 'bdf'
```

### Why Use `slice()`?

* Handy when slicing programmatically:

```python
def custom_slice(data, start, end):
    return data[slice(start, end)]

print(custom_slice([10, 20, 30, 40], 1, 3))  # [20, 30]
```
